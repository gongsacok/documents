# 공사콕 개발 메뉴얼

## 개요

- 본 문서는 개발사항에 관한 주요 기능 및 주요 장비의 설정등을 포함한다.
- 문서에 사용되는 키, 변수명등은 현재의 소스코드를 반영하지 않는다. 현재 소스 코드에 적용되는 부분을 확인하기 위해서는 반드시 소스코드를 참조하도록 한다.
- 문서의 구조는 대분류로서 크게 인프라(장비,네트워크 등), 백엔드, 프론트엔드 앱, 프론트엔드 웹, 데이터베이스로 구성되어 있다.
- 대분류 이하의 내용은 기술 기반의 간략한 설명 및 주요 소스코드를 포함한다. 소스코드는 구성에 참조를 위한 내용이며, 사용되는 변수 및 키등은 현재상황을 반영하지 않는다.
- 중분류에서는 개발 환경 구성, 주요기능에 대한 구성방법, 소스코드의 디렉토리 구조, 주요 오류사항에 대한 대처 방안을 정리한다.

## 인프라

### 개발 공용 환경

#### 인프라 제공

- GitHub 사용
  - 소스 코드 및 개발 관련 버전관리가 필요한 문서등을 보관하기 위하여 버전관리 시스템을 사용하도록 한다.
  - 무료버전의 경우 저장소의 용량, 소스코드 공유 인원등에 따라 제약 있으므로, 초기 개발 시즌의 경우 공유인원을 최소한으로 하도록 한다.
  - 소스코드 형상관리.
    - 최종 소스는 "master:origin" 브랜치를 사용하도록 한다.
    - 소스코드의 통합(merge)는 반드시 빌드 및 배포가 가능한 상태의 소스만을 대상으로 한다.
    - 개인별 소스코드의 작업은 branch로 분리하여 진행하고, merge는 운영자 또는 메인 개발자의 컨펌 후 진행하도록 한다.
- AWS 사용.
  - 테스트 사이트 및 운영 사이트의 인프라를 위하여 사용하도록 한다.
  - DNS 서비스
    - Route53 서비스를 이용하여 사내 개발 서버를 포함한, 개발에 필요한 도메인 작업을 진행하도록 한다.
    - 사내 개발 환경의 경우 "dev[*].gongsacok.com" 을 사용한다.
    - 테스트 환경의 경우 "test[*].gongsacok.com" 을 사용한다.
    - 실서버의 경우 "gongsacok.com" 을 사용한다.
- Google Firebase 사용.
- Naver 개발센터 사용.
- GitHub 사용

### 개발 사이트

#### 개발자 임의 환경

- 개발자는 사내 테스트 호스트를 이용하기 어려운 경우. 개발자 자신의 개발환경에 맞추어 자체적인 테스트 환경을 임의로 구성할 수 있다.

#### 사내 테스트 호스트

- 개발자간 네트워크를 통하여 기능 검증 및 서버 구성 테스트를 위한 환경.
- OS 종류 : Ubuntu 20.04.4 LTS
- 하드웨어 스펙 : 일반 사무용 PC
- Java Runtime 설치
- 데이터 베이스 설치 : MySQL8

### 테스트사이트

#### AWS

-  개발된 소스코드를 서비스 상태에서 테스트 하기 위한 인프라를 구축한다.
- AWS를 사용하여 실제 서비스상태와 유사한 상태를 유지하도록 하며, 부하를 제외한 나머지 설정 및 운영 방식에 차이를 최소한으로 하도록 한다

#### DNS

- Route53 서비스를 이용한다.
- DNS 이름 구매처에서 네임서버를 aws에서 제공하는 서버로 변경한다. (해당 내용은 Route53 서비스 화면에 있음.)
- 도메인에 대한 Zone을 생성한다.
- Zone 편집 화면에서 각 호스트를 등록한다.

#### S3

- 공유저장소로 S3를 사용한다.
  - s3는 저장소 서비스로서, 속도는 조금 떨어지지만, 용량대비 비용면에서 인스턴스에 볼륨을 추가하는 것 보다 장점이 있으므로 사용한다.
  - 2022년7월 현재 1T 기준 저장소 요금이 약 3만원, 데이터 전송용량에 따른 비용발생.
- S3 버킷 생성
- 생성된 버킷의 편집 버튼을 선택한 후 정책선택기를 눌러 정책 생성창을 눌러 정책을 생성한다.
  - 외부의 데이터를 s3에 보내게 되고, 임의 사람이 웹사이트를 통하여 접속하여 해당 이미지를 볼수 있도록 하는 시나리오를 구성한다.
  - 정책생성기의 폼을 이용하여 JSON 형태의 정책을 생성한다.
  - 생성된 정책을 편집창에서 붙여넣어 적용한다.
- 설정된 버킷의 사용자를 추가한다.
  - 알맞은 권한(ex: s3fullaccess)을 가진 사용자를 생성하고, 해당 사용자의 키를 다운로드 받아 둔다.

### 운영 사이트

- 운영에 필요한 인프라 환경.

## 백엔드 (Spring Boot)

### 프레임워크 특징

- Java 기반의 경량형 백엔드 구현 프레임 워크
- 별도의 컨테이너 설정이 없이 spring boot 프레임워크 안에 배포용 tomcat 컨테이너 포함.
- 다양한 라이브러리 지원 (Gradle 프로젝트 관리 툴을 이용하여, 관련 라이브러리의 손쉬운 설치 및 관리.)

### 개발 환경 구성

#### Java 환경 구성

- 오라클자바 또는 OpenJDK중 선택하여 구성.
- https://openjdk.java.net/ 에서 최신 버전을 확인하고, 알맞은 버전을 선택한다.
- 버전 화면에서 상세버전을 확인후 압축버전을 다운로드 한다.
- 다운로드한 파일을 압축해제 하여 설치 위치에 복사한다. (C:\java\jdk18)
- 설정 -> 시스템 -> 고급시스템설정 -> 환경변수를 선택하여 환경변수를 등록한다.

  - 시스템 변수에 새로 JAVA_HOME, C:\java\jdk18 을 설정한다.

  - 시스템 변수의 PATH 항목에 %JAVA_HOME%\bin 를 설정한다.
- 파워쉘 또는 명령어 프롬프트를 열어 java 명령어를 실행하여 설치 상태를 확인한다.

#### IDE (Intellij-ce) 구성

- 자바관련 코드를 하기 위한 IDE 환경으로 인텔리제이를 사용한다.
- 대표 홈페이지에서 커뮤니티 버전(무료)을 다운로드 하여 설치한다.
  - 커뮤니티 버전의 경우 각종 plug-in 사용에 제약이 있으므로 주의 하도록 한다.

### 주요기능별 설정 및 구현

#### Spring Boot Project 초기화

- https://start.spring.io/ 에서 프로젝트 종속성 선택 후 소스코드 다운로드.
  - select java gradle project
  - select Boot version 2.7
  - select java version 17
  - select “spring web” dependency
  - Project meta 데이터를 알맞게 작성한다.
- Generate 버튼을 클릭하여 기본 프로젝트 파일 다운받아. 알맞은 디렉토리에 압축을 해제한다.
- 압축해제된 디렉토리를 사용하는 IDE(Intellij)를 이용하여 오픈하여 내용을 확인한다.

#### GIt 연동

- GitHub 가입
- 프로젝트이름과 같도록(service) private의 빈 리포지토리를 생성한다.
- 인텔리제이의 VCS->Create Git Repository 선택.
- 개발장비의 로컬 repository 선택. (소스코드 디렉토리 선택.)
- 인텔리제의 Git->Manage Remotes 선택
  - +버튼을 이용하여 새로운 리모트 리포지토리 추가.
  - 리모트의 이름은 origin으로 하고, github에서 생성한 빈 리포지토리의 url을 입력. (https://github.com/gongsacok/service.git)
  - Git -> Commit을 선택하여 소스코드를 커밋한다.
  - Git -> Push를 선택하여 소스코드를 리모트 리포지토리에 업로드한다.
- 이후 개발자는 리포지토리를 clone하여 쉽게 개발 환경을 구성할 수 있다.

#### JPA 구성

- JPA는 자바객체를 이용하여 데이터베이스를 이용하는 ORM 을 지원한다.

- Spring Boot에서 hibernate를 사용하여 용이하게 jpa를 이용하도록 한다.

- build.gradle를 설정하도록한다. (데이터베이스 관련 및 DTO 등의 활용을 용이하게 하기위한 Lombok 라이브러리 포함.)

  ``` sh
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  implementation 'mysql:mysql-connector-java'
  implementation 'org.projectlombok:lombok'
  annotationProcessor 'org.projectlombok:lombok'
  ```

- application.yaml 파일을 수정한다. (기본으로 생성되어 있는 application.properties 파일을 이름 변경한다.)

  ``` sh
  spring:
   datasource:
     driver-class-name: com.mysql.cj.jdbc.Driver
     password: cokroqkf
     username: cokdev
     url: jdbc:mysql://devdb.gongsacok.com:3306/cokdev?useSSL=false&characterEncoding=UTF-8&allowPublicKeyRetrieval=true
   jpa:
     database: mysql
     database-platform: org.hibernate.dialect.MySQL8Dialect
     generate-ddl: true
     show-sql: true
  ```

  - yaml 형식의 파일은 문장앞에 space * 2 로 줄바뀜을 구분한다.

- Grade 에서 bootRun 을 이용하여 실행해, 설정을 확인한다.

- Entity 구성

  - Entity는 데이터베이스 테이블 스키마와 대응되는 구조를 가진다.
  - 구성시 반드시 유니크 키 (@Id) 존재하여야 한다.
  - Entity 클래스 추가후 스프링부트 재시작시 데이터베이스 스키마가 생성되는 것을 확인할 수 있다.
  - Entity 클래스에 직접 데이터를 가공할 수 있으나, 보안 및 프로그램 작성시 규칙성을 위하여 반드시 Dto 클래스를 통해 정보를 변경하도록 한다.

- Repository 구성

  - 리포지토리는 기본적으로 인터페이스로서 해당 인터페이스를 선언만 하여도 기본적인 하이버네이트의 조회, 삽입등의 method를 이용할 수 있도록 한다.
  - 해당 리포지토리는 서비스 클래스에서 @Autowired 어노테이션을 이용하여 인스턴스를 생성하여 사용한다.

- 네이티브 쿼리를 위한 커스텀 리포지토리 구성

  - 일반 jpa의 쿼리 메소드를 이용해서는 복잡하거나, orm의 종속관계가 없는 테이블의 join등이 어려우므로, 기존의 쿼리문을 작성하여 쿼리를 실행하는 커스텀 리포지토리를 구성하고, 기존의 repository의 상속관계에 추가한다.

    - 커스텀 리포지토리

      ``` java
      public interface UserInfoRepositoryCustom {
          List<UserInfoAllDto> findByIdAll(Long id); // 구현체에서 구현해야 할 쿼리.
      }
      ```

    - 기존의 리포지토리에 상속관계 추가

      ``` java
      public interface UserInfoRepository extends JpaRepository<UserInfo, Long>, UserInfoRepositoryCustom /*새로운 레파지토리 인터페이스 상속 추가*/ {
          Optional<UserInfo> findByUserid(String userid); //기존 사용중인 jpa 쿼리 메소드.
      }
      ```

  - 커스텀 리포지토리는 해당 리포지토리를 구현하는 구현체(implement) 클래스를 가져야 한다.

    - 구현체는 @PersistenceContext 어노테이션을 이용하여 일반적은 Prepared Query 형태를 이용한다.

    - 쿼리내용을 Dto로 변경하기 위하여 중복 되는 코드를 줄이기 위하여 ModelObject 를 사용하기도 하나, 코드 유지보수시 명확성이 떨어지고, Model Object가 쿼리마다 알맞은 형태로 Dto와 유사하게 클래스로 매핑 되어 있어야 하므로, 본 문서에서는 아래와 같은 샘플 코드를 사용한다.

      ``` java
      public class UserInfoRepositoryCustomImpl implements UserInfoRepositoryCustom {
          @PersistenceContext
          private EntityManager entityManager;
      
          @Override // 구현체이므로 @Override 어노테이션을 사용한다.
          public List<UserInfoAllDto> findByIdAll(Long id) {
              StringBuilder strQry = new StringBuilder();
              int offset = 0;
              int size = 100;
      
              strQry.append("select " +
                      "ui.uid,ui.userid,ui.userrole,udi.name,udi.use_flag " +
                      "from " +
                      "user_info ui " +
                      "join user_detail_info udi on ui.uid = udi.ruid " + // 조인 테이블 및 조건 설정.
                      "where 1=1 " + // 검색조건을 문자열 뒤에 붙이기 위하여 where 절을 항상 첨부.
                      "and ui.uid=:uid "); // 검색조건의 변수 설정.
      
              strQry.append("order by ui.uid desc " +
                      "limit :offset,:size");
      
              Query qry = entityManager.createNativeQuery(strQry.toString());
      
              qry.setParameter("uid",id); // query 시 사용할 변수를 설정한다.
              qry.setParameter("offset", offset);
              qry.setParameter("size", size);
      
              List<Object[]> result = qry.getResultList();
      
              int rowCount = 0;
              // 복수의 쿼리 결과물을 순회하면서 결과 표시.
              for(Object[] item:result) {
                  System.out.println(item[0]+" "+item[1]+" "+item[2]+" "+item[3]+" "+item[4]);
                  rowCount++;
              }
      
              System.out.println("custom implements repository");
              return null;
          }
      }
      ```

  - 서비스에서 리포지토리를 사용하는 경우 기존의 리포지토리를 이용하여 Bean 을 생성 후 사용한다. (Custom repository는 이미 기존의 리포지토리를 통하여 상속 되고 있음.)

    - 서비스 사용 예시.

      ``` java
      
      @Service
      public class TempService {
      
          @Autowired
          private UserInfoRepository userInfoRepository;
          // Custom Repository가 상속되어 사용할 수 있음.
      
          @Autowired
          private UserDetailInfoRepository userDetailInfoRepository;
      
          public void tempUserList() {
              System.out.println("Temporary Service output");
      
              System.out.println("query jpa method user_info");
              Optional<UserInfo> opt = userInfoRepository.findByUserid("aa");
              System.out.println(opt.toString());
      
              System.out.println("query jpa method user_detail_info");
              Optional<UserDetailInfo> opta =userDetailInfoRepository.findById(1L);
              System.out.println(opta.toString());
      
              System.out.println("query with native query");
              List<UserInfoAllDto> rows = userInfoRepository.findByIdAll(1L);
              if(rows!=null) {
                  System.out.println(rows.toString());
              }
          }
      }
      ```

#### JWT Token

- 사용자 로그인 기능을 위하여 토큰 인증을 사용한다.

- 토큰의 유효기간을 두고, 로그인시 신규 발급해준 토큰을 통신시 사용하여 로그인 기능을 구현한다.

- JWT 라이브러리 설정.

  - build.gradle 파일에 종속성 추가.

  - build.gradle 파일 수정후 반드시 gradle 프로젝트를 reload 해주어야 한다.

    ``` sh
    dependencies {
    	implementation 'org.springframework.boot:spring-boot-starter-web'
    	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    	implementation 'mysql:mysql-connector-java'
    	implementation 'org.projectlombok:lombok'
    	implementation 'io.jsonwebtoken:jjwt:0.9.1'
    
    	annotationProcessor 'org.projectlombok:lombok'
    	testImplementation 'org.springframework.boot:spring-boot-starter-test'
    }
    ```

- JWT 생성시 암호 생성.

  - application.yaml 파일에 비밀번호 추가.

    ``` yaml
    jwt:
      secret: coktokensecret
    ```

- 사용자 로그인시 token을 생성하고, db에 저장하도록 한다.

  - 로그인시 controller

    ``` java
    // post 접속을 기본으로 json 형태의 통신을 함.
    @PostMapping(value="/pub/loginToken",consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseDto loginToken(@RequestBody UserInfoDto dto) {
        ResponseDto rtn = ResponseDto.builder().build();
        // database log 남김.
        utilService.addLog("/pub/loginToken",dto.getUserid());
    
        // 입력값 체크
        if(dto.getUserid() != null && dto.getPasswd() != null) {
            if("".equals(dto.getUserid()) || "".equals(dto.getPasswd())) {
                rtn.setStatus("fail");
                rtn.setEmsg("Not valid input value.");
                return rtn;
            } else {
                // 서비스에서 로그인 결과를 받아 응답.
                UserLoginResultDto row = userService.loginToken(dto);
                if(row != null) {
                    rtn.setStatus("success");
                    rtn.setData(row);
                    return rtn;
                } else {
                    rtn.setStatus("fail");
                    rtn.setEmsg("Not matched user info");
                    return rtn;
                }
            }
        } else {
            rtn.setStatus("fail");
            rtn.setEmsg("Not valid input value.");
            return rtn;
        }
    }
    ```

  - 로그인 서비스 (사용자 입력을 통해 데이터베이스와 비교하고, 새로운 토큰을 만들어 리턴하고, 데이터베이스를 갱신한다.)

    ``` java
    public UserLoginResultDto loginToken(UserInfoDto dto) {
        // 사용자 입력 아이디 패스워드를 쿼리한다.
        Optional<UserInfo> optRow = userInfoRepository.findByUseridAndPasswd(dto.getUserid(),EncryptUtil.encryptSHA256(dto.getPasswd()));
        if(optRow.isPresent()) {
            UserInfo row = optRow.get();
            // 새로운 토큰을 생성한다.
            String jtoken = jwtComponent.createToken(dto.getUserid(), dto.getUserrole());
            row.setJtoken(jtoken);
            // 데이터 베이스를 업데이트 한다.
            userInfoRepository.save(row);
    
            // 로그인 결과를 Dto로 만든다.
            UserLoginResultDto rtnRow = UserLoginResultDto.builder().build();
            rtnRow.setUid(row.getUid());
            rtnRow.setUserid(row.getUserid());
            rtnRow.setUserrole(row.getUserrole());
            rtnRow.setJtoken(jtoken);
    
            return rtnRow;
        } else {
            // 데이터가 없는 경우 null을 리턴.
            return null;
        }
    }
    ```

  - jwt를 위한 컴포넌트 (서비스에서 사용)

    ``` java
    @Component
    public class JwtComponent {
        @Value("${jwt.secret}")
        private String jwtSecret;
    
        // 토큰의 유효시간을 24시간으로 한다.
        private long tokenValidTime = 24 * 60 * 60 * 1000L;
    
        private String claimUserid;
        private String claimRole;
    
        // 토큰 생성.
        public String createToken(String userPk, String roles) {
            Claims claims = Jwts.claims().setSubject(userPk); // JWT payload 에 저장되는 정보단위
            claims.put("roles", roles); // 정보는 key / value 쌍으로 저장된다.
            Date now = new Date();
            return Jwts.builder()
                    .setClaims(claims) // 정보 저장
                    .setIssuedAt(now) // 토큰 발행 시간 정보
                    .setExpiration(new Date(now.getTime() + tokenValidTime)) // set Expire Time
                    .signWith(SignatureAlgorithm.HS256, jwtSecret)  // 사용할 암호화 알고리즘과
                    // signature 에 들어갈 secret값 세팅
                    .compact();
        }
    
        // 토큰 비교.
        public boolean validateToken(String token) {
            try {
                Claims claims = Jwts.parser().setSigningKey(DatatypeConverter.parseBase64Binary(jwtSecret))
                        .parseClaimsJws(token).getBody();
                this.claimUserid = claims.getSubject();
                this.claimRole = claims.get("roles",String.class);
                return true;
            } catch (Exception e) {
                System.out.println("exception occured on process jtoken");
                return false;
            }
        }
    
        public String getClaimUserid() {
            // 향후 help method.
            return this.claimUserid;
        }
    
        public void getTokenInfo() {
            // 향후 help method.
            return;
        }
    
        public String resolveToken(HttpServletRequest request) {
            // 향후 help method.
            return request.getHeader("Authorization");
        }
    }
    ```

#### Spring Security 구성

- Spring boot에서 제공하는 로그인 방법을 사용하여, 디렉토리별 권한별 접근등을 제어 한다. Spring Boot Security는 설치와 함께, 설정이 필요하고, 설정에 따라 BackEnd 어플리케이션 세션, 로그인 등의 기능을 대치 하므로, 주의하여야 한다.

- 향후 확장 구조 (OAuth)를 이용하기 위해서 필수인 경우가 많으므로, 본 문서에서는 userid, password를 받아 token정보를 리턴해주고, 토큰정보를 통하여 로그인 사용자를 구분하는 기능을 Spring security 환경에서 구성하여 사용하도록 한다.

- Spring Security 라이브러리 설정.

  ``` sh 
  implementation 'org.springframework.boot:spring-boot-starter-security'
  ```

  - 프로젝트를 실행 하면, 기본적으로 설정된 아이디와 패스워드가 실행 콘솔에 표시되므로, 개발시에 참고 하도록 한다. 해당 패스워드는 재시작시 마다 새롭게 갱신된다.

    ``` sh
    Using generated security password: 7fde4b12-b166-421b-a6e0-ef9a9ad5cd89
    ```

- 기본 설정

  - Spring Boot Security를 설치하면 전체 페이지가 Unauthorized 상태가 된다. 간략한 설정을 먼저 적용하여 페이지 접근을 허용하도록 한다.

  - Config 디렉토리에 설정을 위한 클래스를 생성하고, @Configuration 어노테이션을 이용하여 설정 클래스임을 선언한다.

    ``` java
    @Configuration
    @EnableWebSecurity
    @RequiredArgsConstructor
    public class SecurityConfiguration {
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.csrf().disable(); // 크로스 오리진 체크를 사용하지 않는다.
            http.authorizeRequests()
                    .antMatchers("/pub/**").permitAll(); // /pub/ 하위의 디렉토리는 모두에게 오픈한다.
            http.sessionManagement()
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS); // security가 세션 관리를 하지 않는다.
            return http.build();
        }
    }
    ```

- 로그인기능 구현

  - 상기의 로그인 이외에 security를 이용한 로그인 컨트롤러를 생성한다.

    ``` java
    @PostMapping(value = "/pub/login", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseDto login(@RequestBody UserInfoDto dto) {
        ResponseDto rtn = ResponseDto.builder().build();
        utilService.addLog("/pub/login", dto.getUserid());
    
        if (dto.getUserid() != null && dto.getPasswd() != null) {
            if ("".equals(dto.getUserid()) || "".equals(dto.getPasswd())) {
                rtn.setStatus("fail");
                rtn.setEmsg("Not valid input value.");
                return rtn;
            } else {
                UserLoginResultDto row = userService.login(dto); // 서비스에서 로그인 결과를 받아 응답.
                if (row != null) {
                    rtn.setStatus("success");
                    rtn.setData(row);
                    return rtn;
                } else {
                    rtn.setStatus("fail");
                    rtn.setEmsg("Not matched user info");
                    return rtn;
                }
            }
        } else {
          rtn.setStatus("fail");
          rtn.setEmsg("Not valid input value.");
          return rtn;
        }
    }
    ```

- 로그인 서비스 구현.

  - 기존의 서비스와 다르게 security 기능을 이용하여, 로그인을 수행한다. 해당 로그인을 수행하기 위하여 추가적인 securiy 관련 class 및 configuration 클래스의 수정이 필요하다.

  - SecurityConfiguration 클래스를 수정한다.

    ``` java
    @Configuration
    @EnableWebSecurity
    @RequiredArgsConstructor
    public class SecurityConfiguration {
        // 인증을 담당할 클래스 선언 (사용자 인증시 사용할 서비스를 설정.)
        @Autowired
        private SecurityUserDetailService securityUserDetailsService;
    
        // 인증 방법에 대한 설정을 추가. (인증을 담당하는 매니저를 설정.)
        @Bean
        protected AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
            return configuration.getAuthenticationManager();
        }
    
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.csrf().disable();
            http.authorizeRequests()
                    .antMatchers("/pub/**").permitAll();
            http.authorizeRequests()
                    .anyRequest().authenticated();
            http.sessionManagement()
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
            return http.build();
        }
    }
    
    ```

  - 설정 클래스에서 사용할 인증 서비스인 SecurityUserDetailService를 생성한다.

    ``` java
    
    @Service
    public class SecurityUserDetailService implements UserDetailsService {
        @Autowired
        private UserInfoRepository userInfoRepository;
    
        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            // 인증을 위해서 비교해야 할 사용자 정보를 로드 하여 UserDetail 클래스로 리턴한다.
            if(SecurityContextHolder.getContext().getAuthentication()==null) {
                // System.out.println("인증정보 없는 경우 : login 외의 접근.");
            } else {
                // System.out.println("인증정보 있는 경우 : login 시 authenticate() 호출 후");
            }
    
            Optional<UserInfo> optItem = userInfoRepository.findByUserid(username);
            UserInfo item = null;
    
            if(optItem.isPresent()) {
                // 데이터 베이스에서 유저 정보를 가져온다.
                item = optItem.get();
            } else {
                throw new UsernameNotFoundException("User not found with username: " + username);
            }
    
            List<String> authList = Arrays.asList(item.getUserrole().split(","));
    
            // 데이터베이스에서 가져온 정보의 이름이 사용자가 입력한 사용자 명과 동일하다면, 사용자 정보를 생성한다.
            if (item.getUserid().equals(username)) {
                return SecurityUserDetail.builder()
                        .username(item.getUserid())
                        .password("{noop}"+item.getPasswd())
                      	// 사용자 패스워드는 평문으로 비교하기 위하여 "{noop}"을 추가한다.
                        .btoken(item.getJtoken())
                        .roles(authList)
                        .uid(item.getUid())
                        .build();
            } else {
                throw new UsernameNotFoundException("User not found with username: " + username);
            }
        }
    }
    ```

  - SpringSecurity에서 사용할 유저 정보(principal)를 저장하는 클래스를 상속받아 추가하고 필요한 함수들을 override 하여 구현을 추가한다.

    ``` java
    @Builder
    @Getter
    @Setter
    public class SecurityUserDetail implements UserDetails {
        private String username;
        private String password;
        private String btoken;
        private Long uid;
        private List<String> roles;
    
        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            // 리스트로 주어진 권한을 authorities로 변환한다. 권한은 "ROLE_XXXX" 의 형태이어야 한다.
            List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();
            for(int i=0; i<roles.size(); i++) {
                authorities.add(new SimpleGrantedAuthority(roles.get(i)));
            }
            return authorities;
        }
    
        @Override
        public String getPassword() {
            return this.password;
        }
    
        @Override
        public String getUsername() {
            return this.username;
        }
    
        @Override
        public boolean isAccountNonExpired() {
            // 기본값인 false 인경우 어카운트가 만료된것 이므로, 만료되지 않음을 true 수정한다. 
          	// (아래의 오버라이드 함수도 동일한 처리)
            return true;
        }
    
        @Override
        public boolean isAccountNonLocked() {
            return true;
        }
    
        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }
    
        @Override
        public boolean isEnabled() {
            return true;
        }
    }
    ```

  - 해당 클래들을 이용해서 서비스 클래스에서 로그인 처리를 수행하도록 한다.

    ``` java
    public UserLoginResultDto login(UserInfoDto dto) {
        UserLoginResultDto rtnDto = UserLoginResultDto.builder().build();
        try {
            // 인증을 위해 하단의 인증 메소드에 입력받은 아이디와 sha1 처리된 패스워드를 전달한다.
            Authentication auth = authenticate(dto.getUserid(), EncryptUtil.encryptSHA256(dto.getPasswd()));
          	// 인증된 유저의 정보를 얻어온다.
            SecurityUserDetail detail = (SecurityUserDetail) auth.getPrincipal();
          	// 인증된 유저의 사용자 권한을 파싱한다.
            String strRoles = detail.getAuthorities().toString().replaceAll("\\s+","");
            strRoles = strRoles.substring(1,strRoles.length()-1);
    
          	// 로그인 한 유저의 토큰을 생성한다.
            String jtoken = jwtComponent.createToken(detail.getUsername(), strRoles);
    
          	// 응답할 내용을 생성한다.
            rtnDto.setUserid(dto.getUserid());
            rtnDto.setJtoken(jtoken);
            rtnDto.setUserrole(strRoles);
            rtnDto.setUid(detail.getUid());
    
            // database 의 토큰을 업데이트 한다.
            updateUserToken(detail.getUid(),jtoken);
    
            return rtnDto;
        } catch (Exception e) {
            // System.out.println("TOKEN CREATE FAILURE.");
            // System.out.println(e.toString());
            return null;
        }
    }
    
    // 인증을 수행할 메소드.
    private Authentication authenticate(String username, String password) throws Exception {
        try {
          	// 인증매니저의 함수를 실행시키고, 해당 메소드는 유저네임,패스워드를 받아 토큰을 생성하는 방식의 로그인을 수행한다.
          	return authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        } catch (DisabledException e) {
            // 인증시 에러를 예외처리 한다.
            System.out.println("user diabled");
            throw new Exception("USER_DISABLED", e);
        } catch (BadCredentialsException e) {
            System.out.println("invalide credentials");
            throw new Exception("INVALID_CREDENTIALS", e);
        } catch (Exception e) {
            System.out.println("Exception e : "+e.toString());
            throw new Exception("Unknown Exception", e);
        }
    }
    
    // 데이터 베이스에 신규로 발급된 토큰을 저장한다.
    private void updateUserToken(Long uid, String jtoken) {
        Optional<UserInfo> opt = userInfoRepository.findById(uid);
        if(opt.isPresent()) {
            UserInfo row = opt.get();
            row.setJtoken(jtoken);
    
            userInfoRepository.save(row);
        }
    }
    ```

- Token을 이용한 접속시 권한 체크를 위하여 각 권한별로 접속이 가능한 url을 만든다. (Ex: /pub 은 전체 가능, /svc 는 ROLE_USER만 가능하도록 한다.)

  - 이를 위하여 우선 Configuration 클래스를 수정한다.

  - 또한 해당 접속 url로 요청이 들어 왔을 경우 토큰을 받아 해당 유저를 검증해야 하므로, 컨트롤러 수행전 필터를 추가하도록 한다.

    ``` java
    @Configuration
    @EnableWebSecurity
    @RequiredArgsConstructor
    public class SecurityConfiguration {
        // 인증을 담당할 클래스 선언
        @Autowired
        private SecurityUserDetailService securityUserDetailsService;
    
        // 인증 필터 클래스 선언.
        @Autowired
        private SecurityJwtFilter securityJwtFilter;
    
        // 사용자 구성 인증을 위한 빈 추가.
        // 인증 방법에 대한 설정을 추가.
        @Bean
        protected AuthenticationManager authenticationManager(AuthenticationConfiguration configuration) throws Exception {
            return configuration.getAuthenticationManager();
        }
    
        @Bean
        public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
            http.csrf().disable();
            http.authorizeRequests()
                    // admin url 시작은 admin 권한을 가진 사용자만 접근가능.
                    .antMatchers("/admin/**").hasAuthority("ROLE_ADMIN")
                    // svc url 시작은 user 권한을 가진 사용자만 접근가능.
                    .antMatchers("/svc/**").hasAuthority("ROLE_USER")
                    // pub url 시작은 전체가 접근가능.
                    .antMatchers("/pub/**").permitAll();
            http.authorizeRequests()
                    .anyRequest().authenticated();
            // 매 요청마다 token을 통해 인증하므로, 세션을 유지하지 않는다.
            http.sessionManagement()
                    .sessionCreationPolicy(SessionCreationPolicy.STATELESS);
            // 필터를 추가한다.
            http.addFilterBefore(securityJwtFilter, UsernamePasswordAuthenticationFilter.class);
            return http.build();
        }
    }
    ```

  - 필터 클래스를 생성하고 구현한다. 필터는 url 호출시 해당 호출을 거쳐서 지나가며, 이때 올바른 사용자라면, Security Context에 권한 정보를 업데이트 한후 사용자가 요청한 request 를 전달하는 방식으로 인증을 수행한다.

    ``` java
    @Component
    public class SecurityJwtFilter extends OncePerRequestFilter {
    		// 토큰을 분석하기 위하여 jwt	token 컴포턴트를 포함한다.
        @Autowired
        private JwtComponent jwtComponent;
    	  // 사용자 Security Context를 생성하기 위하여 사용자 정보 클래스를 포함한다.
        @Autowired
        private SecurityUserDetailService securityUserDetailsService;
    
        // 필터 동작을 위한 오버라이드 함수를 구현한다.
        @Override
        protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
            String tokenHeader = jwtComponent.resolveToken((HttpServletRequest) request);
    
            if(tokenHeader != null) {
                String jwtToken;
                String username = null;
    
                // Bearer Token 인출.
                jwtToken = tokenHeader.substring(7);
    
                // token 검증(만료 또는 비정상토큰 구분) 및 token 사용자명 인출.
                if(jwtComponent.validateToken(jwtToken)) {
                    username = jwtComponent.getClaimUserid();
                }
    
                // 사용자명이 있으며, 로그인 컨텍스트가 없는 경우. Token을 통해 DB정보로 로그인 컨텍스트를 생성해 준다.
                if(username!=null && SecurityContextHolder.getContext().getAuthentication()==null) {
                    //사용자명과 token을 통한 로그인 정보가 존재하면. 로그인한 사용자로 판단.
                    SecurityUserDetail userDetails = (SecurityUserDetail)this.securityUserDetailsService.loadUserByUsername(username);
                    if(userDetails.getBtoken().equals(jwtToken)) {
                        // 인증 컨텍스트 생성.
                        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =
                                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
                        usernamePasswordAuthenticationToken.setDetails(
                                new WebAuthenticationDetailsSource().buildDetails(request));
                        SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
                    }
                }
            }
    			  // 필터에서 처리된 정보를 종합하여 요청 수행을 계속한다. (인증정보가 없을경우, 즉 토큰이 올바르지 않은경우 처리를 계속하면 권한 에러가 발생한다.)
            filterChain.doFilter(request,response);
        }
    }
    ```

#### OAuth 클라이언트 로그인

- 본 프로젝트에서 사용되는 oauth는 웹 클라이언트 방식으로서, 로그인 화면부터 oauth를 제공하는 회사의 api 를 사용해 로그인을 구성하는 방식과는 다른 방식이다.

- 네이버 아이디 로그인
  - 네이버 계정에서 개발자 신청 한다.
  
  - 네이버 개발자 센터에서 application 이름과 사용할 api를 선택하여 application 생성한다.
  
  - 어플리케이션에서 사용할 키와 상세 설정을 수행한다.
  
  - 아이디 로그인의 경우 웹 기반으로 설정하고, 콜백 url에 개발 장비의 url을 입력하도록 한다.
  
  - 클라이언트(프론트앤드 웹, 앱)와 서버(백엔드)의 업무 흐름은 아래와 같다.
    - 프론트앤드에서 네이버 로그인화면을 표시한다.
    - 네이버에서 로그인된 상태를 검증하여 등록된 백엔드 서버에 callback url을 통하여 전송한다.
    - 서버에서 프론트로 부터 요청된 콜백을 이용하여 사용자 정보를 받아 온다.
    - 사용자 정보를 처리하고, 앱의 경우 url scheme 형식으로 응답을 보낸다.
    - url scheme으로 반환된 상태정보를 이용하여 앱의 나머지 기능을 수행한다.
    
  - 앱에서 로그인 결과 정보를 받을수 있는 백엔드 callback url의 controller를 작성한다.
    
    ``` java
    @GetMapping(value="/pub/naverauth")
    public ResponseEntity<String> naverauth(@RequestParam(value = "code")String code, @RequestParam(value="state")String state) {
        utilService.addLog("/pub/naverauth",code+":"+state);
    
      	// naver 서버로 부터 사용자 정보를 가져온다.
        UserLoginResultDto result = userService.naverGetProfile(userService.naverGetAccessToken(code,state));
    
        // 리턴해줄 해더를 만든다.
        HttpHeaders responseHeader = new HttpHeaders();
        if(result!=null) {
            // 로그인 성공시 헤더. (url scheme을 통한 앱과의 연동)
            responseHeader.add("Location","gongsacoknaverlogin://success?uid="+result.getUid()+
                               "&userid="+result.getUserid()+"&jtoken="+result.getJtoken()+"&userrole="+result.getUserrole());
        } else {
            // 로그인 실패시 헤더. (url scheme을 통한 앱과의 연동)
            responseHeader.add("Location","gongsacoknaverlogin://fail?code="+code+"&state="+state);
        }
    		
      	// 생성한 헤더정보를 이용하여 페이지 리디렉션.
        return new ResponseEntity<>("{\"code\":\""+code+"\"",responseHeader, HttpStatus.resolve(307));
    }
    ```
    
  - 수신한 정보를 이용하여, 써드파티 회사의 서버에 접속하여 사용자 AccessToken을 받는다.
  
    ``` java
    public String naverGetAccessToken(String code, String state) {
        // 네이버 억세스 토큰 요청 api 생성.
        String tokenUrl = "https://nid.naver.com/oauth2.0/token";
        tokenUrl = tokenUrl + "?grant_type=authorization_code";
        tokenUrl = tokenUrl + "&client_id=CgwrY2ZJKgurXGVWpiTk";
        tokenUrl = tokenUrl + "&client_secret=cWWmn6dRCb";
        tokenUrl = tokenUrl + "&code="+code;
        tokenUrl = tokenUrl + "&state="+state;
    
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<String> response = restTemplate.getForEntity(tokenUrl, String.class);
    
        try {
            // 네이버 인증 성공시 억세스 토큰 반환.
            NaverTokens model = objectMapper.readValue(response.getBody(), NaverTokens.class);
            return model.getAccess_token();
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return null;
        }
    }
    ```
  
  - AccessToken을 이용하여, 사용자의 프로필을 가져온다. 사용자 프로필을 가져올 수 있다면, 로그인 상태로 판단할 수 있음.
  
    ``` java
    public UserLoginResultDto naverGetProfile(String accessToken) {
        // 네이버 프로파일 정보 가져오기.
        String profileUrl = "https://openapi.naver.com/v1/nid/me";
        HttpHeaders httpHeaders = new HttpHeaders();
        httpHeaders.add("Authorization","Bearer "+accessToken);
    
        RestTemplate restTemplate = new RestTemplate();
        HttpEntity request = new HttpEntity(httpHeaders);
        ResponseEntity<String> response = restTemplate.exchange(profileUrl, HttpMethod.GET,request,String.class);
    
        try {
            NaverUser nuser = objectMapper.readValue(response.getBody(), NaverUser.class);
    
            // 데이터베이스에서 로그인 한 유저인지 판단.
            if(!isNaverUser(nuser)) {
                // 데이터베이스에 사용자 등록.
                addNaverUser(nuser);
            }
    
            // 사용자 정보에 맞추어 정보 리턴.
            UserInfoDto uInfo = UserInfoDto.builder().build();
            uInfo.setUserid("Naver:"+nuser.getResponse().getId());
            uInfo.setPasswd(nuser.getResponse().getId());
            // 시스템에 로그인 수행. (토큰 발급)
            UserLoginResultDto result = login(uInfo);
    
          	return result;
        } catch (JsonProcessingException e) {
            e.printStackTrace();
            return null;
        }
    }
    ```

#### AWS S3 연동

- 서비스시 AWS의 인스턴스에 저장소를 업로드된 이미지 들을 보관하기에는 비용이 크므로 (1T 기준 약 8.5만원 정도 s3의 3배정도 가격) s3에 저장소를 만들어 연동하도록 한다.

- aws에서 s3를 구성한다. (본 문서의 인프라 항목 참조.)

- aws spring boot 라이브러리를 설치한다. build.gradle 파일에 라이브러리를 추가한다.

  ``` sh
  implementation 'io.awspring.cloud:spring-cloud-starter-aws:2.3.1'
  ```

- s3 관련 정보를 application.yaml에 설정하면서, spring boot의 파일 업로드 사이즈도 조정해준다.

  ``` yaml
  spring:
    servlet:
      multipart:
        max-file-size: 20MB
        max-request-size: 20MB
  cloud:
    aws:
      credentials:
        accessKey: AKIA52SAR7AKAZONELGB
        secretKey: 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
      s3:
        bucket: gongsacok-dev
      region:
        static: ap-northeast-2
      stack:
        auto: false
  ```

- spring boot 어플리케이션에서 s3를 지원하기 위하여 설정 클래스를 생성한다. (/configs/AwsS3Config.java)

  ``` java
  @Configuration
  public class AwsS3Config {
      @Value("${cloud.aws.credentials.accessKey}")
      private String accessKey;
  
      @Value("${cloud.aws.credentials.secretKey}")
      private String secretKey;
  
      @Value("${cloud.aws.region.static}")
      private String region;
  
      @Bean
      public AmazonS3Client amazonS3Client() {
          BasicAWSCredentials awsCreds = new BasicAWSCredentials(accessKey, secretKey);
          return (AmazonS3Client) AmazonS3ClientBuilder.standard()
                  .withRegion(region)
                  .withCredentials(new AWSStaticCredentialsProvider(awsCreds))
                  .build();
      }
  }
  ```

  - 업로드 되는 이미지 파일의 정보를 저장하기 위한 Entity를 생성한다.

    ``` java
    @Entity
    @Getter
    @Setter
    @ToString
    public class ImageInfo {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long iiid; // 이미지 아이디.
    
        private String storagePath; // s3에 저장되는 이미지 경로.
        private String fileName; // 업로드한 파일명.
    
        private LocalDateTime createTime;
        private LocalDateTime updateTime;
    }
    ```

  - 이미지 또는 파일 업로드를 위한 Controller를 생성한다. (파일 업로드의 경우 multipart 를 이용한 form 기반 업로드를 이용한다.)

    ``` java
    @PostMapping(value="/svc/upImages")
    // dto를 통한 json 방식이 아닌 form/multipart 형식의 통신.
    public ResponseDto upImages(@RequestHeader("Authorization") String jtoken, @RequestParam MultipartFile[] Imgs) {
      	// log 생성 및 저장 시작.
        ResponseDto rtn = ResponseDto.builder().build();
        String logString = "";
        for(int i=0; i<Imgs.length; i++) {
            MultipartFile mf = Imgs[i];
            if(i!=0) {
                logString=logString+"|"+mf.getOriginalFilename();
            } else {
                logString=mf.getOriginalFilename();
            }
        }
        utilService.addLog("/svc/upImages",logString);
      	// log 생성 및 저장 끝. (기능상 영향없음.)
    
      	// 폼에 포함된 이미지 데이터를 받아 서비스에 전달.
        ArrayList<String> result = fileService.uploadImages(Imgs);
        if(result.size() != 0) {
          	// 성공 응답.
            rtn.setStatus("success");
            rtn.setData(Arrays.asList(result.toArray()));
            return rtn;
        } else {
          	// 실패시 에러전송.
            rtn.setStatus("fail");
            rtn.setEmsg("error in process");
    	      return rtn;
        }
    }
    ```

  - 컨트롤러에서 사용할 서비스 생성

    ``` java
    public ArrayList<String> uploadImages(MultipartFile[] imgs) {
      	// upload 이미지 path를 리턴함
        ArrayList<String> rtnPaths = new ArrayList<>();
        Instant instant = Instant.now();
    
      	// 이미지 갯수에 따라서 중복 처리
        for(int i=0; i<imgs.length; i++) {
            MultipartFile mf = imgs[i];
            String fileName = instant.getEpochSecond()+"_"+mf.getOriginalFilename();
            ObjectMetadata objectMetadata = new ObjectMetadata();
            objectMetadata.setContentType(mf.getContentType());
            try {
              	// 스트림 생성후 업로드
                InputStream inputStream = mf.getInputStream();
                PutObjectRequest putObj = new PutObjectRequest(bucketName, fileName, inputStream, objectMetadata)
                  .withCannedAcl(CannedAccessControlList.PublicRead);
                amazonS3Client.putObject(putObj);
                String uploadUrl = amazonS3Client.getUrl(bucketName,fileName).toString();
                rtnPaths.add(uploadUrl);
    
              	// 데이터 베이스에 이미지 하나에 하나의 레코드를 삽입.
                ImageInfo row = new ImageInfo();
                row.setFileName(fileName);
                row.setStoragePath(uploadUrl);
                row.setCreateTime(LocalDateTime.now());
                row.setUpdateTime(LocalDateTime.now());
    
                imageInfoRepository.save(row);
            } catch (Exception e) {
                System.out.println("Exception e : "+e.toString());
            }
        }
        return rtnPaths;
    }
    ```

#### WebSocket 구성

- 채팅 및 기타 기반 서비스를 위해 웹소켓 기능을 구현 한다.

- 웹소켓은 웹 브라우저 또는 웹 기술 기반 위에서 소켓 형태의 통신을 가능하도록 함.

- 웹 소켓은 소켓과 유사하게 동작을 하지만, 웹기반에서 움직이는 것으로 소켓과는 다름에 주의하도록 한다.

- 스프링 부트 웹소켓 라이브러리를 설치한다.

  ``` sh
  implementation 'org.springframework.boot:spring-boot-starter-websocket'
  ```

- 소켓 설정 클래스 WebSocketConfig 클래스를 생성한다.

  ``` java
  @Configuration
  @EnableWebSocket
  public class WebSocketConfig implements WebSocketConfigurer {
      // 서비스에서 사용자 만든 클래스를 import 하도록 한다.
      private final WebSocketHandler webSocketHandler;
  
      public WebSocketConfig(WebSocketHandler webSocketHandler) {
          this.webSocketHandler = webSocketHandler;
      }
  
      @Override
      public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        	// "/socket" 으로 들어오는 소켓을 소켓 핸들러에 설정한다.
          registry.addHandler(webSocketHandler, "/socket").setAllowedOrigins("*");
      }
  }
  ```

- 서비스에 해당 웹소켓의 핸들러(소켓의 데이터를 처리하는)를 생성한다.

- 문서의 소스코드는 기본적인 기능 확인을 위한 핸들러를 기반으로 Text 로그를 출력하도록 되어 있음.

  ``` java
  @Component
  public class CustomWebSocketHandler extends TextWebSocketHandler {
      // 접속한 클라이언트들의 세션정보를 저장할 리스트맵 데이터.
      private static final ConcurrentHashMap<String, WebSocketSession> CLIENTS = new ConcurrentHashMap<String, WebSocketSession>();
  
    	// 클라이언트로 부터 접속이 완료 된후 실행 되는 메소드. 클라이언트 세선을 추가한다.
      @Override
      public void afterConnectionEstablished(WebSocketSession session) throws Exception {
          CLIENTS.put(session.getId(), session);
          System.out.println("connect from client : remain session is "+CLIENTS.size());
      }
  
      // 접속이 끊어진후 실행되는 메소드. 클라이언트 세션을 삭제한다.
      @Override
      public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
          CLIENTS.remove(session.getId());
          System.out.println("disconnect from client : remain session is "+CLIENTS.size());
      }
  
      // 클라이언트로 부터 메시지가 수신되는 경우 실행되는 메소드.
      @Override
      protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
          System.out.println("message arrived : "+message.getPayload());
          String id = session.getId();
          CLIENTS.entrySet().forEach( arg->{
              if(!arg.getKey().equals(id)) {
                  try {
                      synchronized(arg.getValue()) {
                          arg.getValue().sendMessage(message);
                      }
                  } catch (IOException e) {
                      e.printStackTrace();
                  }
              }
          });
      }
  }
  ```

### 소스코드 구조

- 전체 설정 파일
- 디렉토리 구조
  - Config 디렉토리
    - 프로젝트에 필요한 설정 클래스.
    - 외부의 설정이 필요한 기능을 사용할때 설정을 클래스로 구현하여 프로젝트에 주입(injection) 한다.
  - Controllers 디렉토리
    - api의 접속위치 (url)을 정의하고 요청의 처리를 시작한다.
    - 업무 처리가 아닌 웹기반의 처리를 담당한다.
    - 업무처리후 결과 반환은 ResponseDto 객체를 통하여 리턴하도록 통일하지만, 필요한 경우 별도의 객체를 생성하여 리턴 할 수 있다. 
  - Custom 디렉토리
    - 추가된 기능의 핸들러, 필터등을 모아둔 디렉토리.
    - 각 기능 추가시 설정이외에 추가로 필요한 클래스와 인터페이스들을 포함한다.
  - Dtos 디렉토리
    - 컨트롤러와 서비스의 데이터 교환을 위하여, 변수를 포함하고 있는 객체를 구성해 둔다.
    - 컨트롤러와 이름의 유사성을 유지하여 유지보수성을 확보하도록 한다.
    - dto들은 롬복의 @Builder, @Data 어노테이션을 사용한다.
  - Entities 디렉토리
    - JPA의 entity 객체를 정의한다.
    - 해당 entity들을 통해서 db에 schema가 생성된다. entity의 변경은 허가되지 않은 schema를 변경을 할 수 없으므로, entity 수정시 해당 schema가 변경적용되지 않는다면, 관련 테이블을 삭제한 후 entity 기반으로 새로 생성하도록한다.
  - Models 디렉토리
    - Dto와 유사한 기능을 수행하지만, 클래스에 따라 빌더를 통한 자동 object mapping등에 사용하기 위한 클래스.
    - 주로 외부 api의 통신시 응답에 대한 데이터 형태를 가지는 모델의 형태 등으로 사용.
  - Repositories 디렉토리
    - jpa 의 리포지토리 파일들을 정의한다.
    - 쿼리 업무의 실제적인 구현이 들어가야 한다.
    - 네이티브 쿼리(쿼리문을 통한 쿼리)를 위하여 커스텀 리포지토리를 포함한다.
  - Services 디렉토리
    - 컨트롤러에서 실제의 업무로직을 담당한다.
    - 컨트롤러와 이름의 유사성을 유지하여 유지보수성을 확보하도록 한다.
  - Utils 디렉토리
    - 소스코드 작성시 도움을 줄수 있는 시스템 유틸리티등의 구현을 가지고 있는 클래스들을 포함한다.

### 배포

#### 개발 환경

- 개발환경에서 Gradle의 BootJar 스크립트를 이용하여 jar 확장자를 가지는 배포파일을 빌드한다.

- 기존의 jar 파일을 백업 한다.

  ``` sh
  cd ~/back
  mv  proto-0.0.1-SNAPSHOT.jar  proto-0.0.1-SNAPSHOT.jar.back
  ```

- 기존의 시스템 로그파일을 백업한다.

  ``` sh
  mv nohup.out nohup.out.back
  ```

- 만들어진 jar 파일을 개발 서버에 업로드 한다.

- 실행중인 프로세스를 확인하고, 중단한다.

  ``` sh
  ps -ef | grep java
  
  root      171308  171284  0 May25 pts/0    01:27:57 java -jar /home/workspace/hellotest-0.0.1-SNAPSHOT.jar
  root      189358  189333  0 May26 pts/0    01:40:04 java -jar /home/workspace/hellotest-0.0.1-SNAPSHOT.jar
  jhsim     513288       1  0 Jun08 ?        01:01:52 java -jar proto-0.0.1-SNAPSHOT.jar
  jhsim     687178       1  0 Jun14 ?        00:51:45 java -jar webrtcpoocback-0.0.1-SNAPSHOT.jar
  jhsim    1202595 1201870  0 04:56 pts/0    00:00:00 grep --color=auto java
  
  kill -9 513288
  ```

- 새롭게 업로드한 파일을 데몬 모드로 실행하고, 프로세스가 잘 올라왔는지 확인한다.

  ``` sh
  nohup java -jar service-0.0.1-SNAPSHOT.jar &
  
  ps -ef | grep java
  
  root      171308  171284  0 May25 pts/0    01:27:58 java -jar /home/workspace/hellotest-0.0.1-SNAPSHOT.jar
  root      189358  189333  0 May26 pts/0    01:40:04 java -jar /home/workspace/hellotest-0.0.1-SNAPSHOT.jar
  jhsim     687178       1  0 Jun14 ?        00:51:46 java -jar webrtcpoocback-0.0.1-SNAPSHOT.jar
  jhsim    1202823 1201870 24 04:58 pts/0    00:00:15 java -jar service-0.0.1-SNAPSHOT.jar
  jhsim    1202895 1201870  0 04:59 pts/0    00:00:00 grep --color=auto java
  ```

- 시스템 로그를 확인한다.

  ``` sh
  cat nohup.out
  
    .   ____          _            __ _ _
   /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
  ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
   \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
    '  |____| .__|_| |_|_| |_\__, | / / / /
   =========|_|==============|___/=/_/_/_/
   :: Spring Boot ::                (v2.7.1)
  
  2022-07-08 04:58:45.961  INFO 1202823 --- [           main] c.gongsacok.service.ServiceApplication   : Starting ServiceApplication using Java 11.0.15 on jhsim with PID 1202823 (/home/jhsim/back/service-0.0.1-SNAPSHOT.jar started by jhsim in /home/jhsim/back)
  ......
  ```

- 웹브라우저 및 postman과 같은 클라이언트 툴을 이용하여 접속 및 데이터 처리등이 정상인지 확인한다.

#### 테스트 서버

#### 실서버

### trouble shooting

- Intelli-j 에서 소스코드 구성시, 자바 버전에 따라. build.gradle의 설정이 달라질 수 있다.
  - sourceCompatibility = '14' 항목을 개발 장비의 java 머신과 맞추어 해결하도록 한다.
- git 설정시 권한이 없는 사용자 계정으로 remote repository를 추가하는 경우, 찾을 수 없는 repository라는 에러가 발생한다.
  - github로 로그인한 계정이 어떤 계정인지 확인한다.
  - 다른 사용자로서 해당 리포지토리에 접근 하고자 한다면, github repository 화면에서, Setting 메뉴를 선택하고, collaborator를 추가하도록 한다.
- 프로젝트를 동기화 하거나 다시 가져오는 경우 '@RestController' 등 기본적인 어노테이션등이 해석이 안되는 경우가 발생할 수 있다.
  - build.gradle 파일의 내용을 확인한다. (Implement 되어 있지 않는 어노테이션을 사용할 수 있음.)
  - 최 우측의 gradle 메뉴에서 프로젝트 명을 우측 클릭후 "Refresh" 를 선택하면 종속성을 다시 다운로드 받는다.

- 인텔리제이 재기동시 "Lombok requires annotation processing: Do you want to enable annotation processors?" 와 같은 에러 발생.
  - Lombok은 외부 라이브러리로서, 시스템에 설치 되므로, 해당 에러 발생시 안내되는 링크를 클릭하여 롬복 사용을 활성화 시키도록 한다.


## 프론트엔드 (Flutter)

### 프레임워크 특징

- 하이브리드 모바일 앱 개발을 위한 구글에서 관리하는 프레임워크.
- IOS, Android 앱을 하나의 소스코드 기반으로 개발 관리 할 수 있음.
- 각 모바일 OS에서 제공하는 직접적인 기능을 빠르게 사용하는 용도 이외의 업무용 앱등에 적용하기 용이함.
- 실행 파일(앱 배포시)의 크기 큰 단점이 존재 한다.
- iOS 와 안드로이드 환경을 구성해야 하는데, ios환경은 애플에 종속적이므로 맥을 개발 기기로 사용하거나, 윈도우에서 안드로이드 환경으로 개발 진행후 맥 기기에서 빌드를 수행한다.

### 개발 환경 구성

#### flutter 구성

- 공식사이트에서 다운로드 받아 알맞은 디렉토리에 압축해제한다.

- 윈도우의 경우 알맞은 Path를 설정한다.

  - Path 설정 방식은 백엔드 Java 설치 및 구성을 참고 한다.

- cmd 또는 터미널에서 설치를 확인한다.

  ``` sh
  flutter --version
  ```

- 이후 개발 환경을 설치하도록 한다.

- 개발환경 설치이후 정상적으로 flutter와 연계 할 수 있는지 확인 하기 위하여 진단을 수행하면 현재 시스템의 각종 현황을 확인할 수 있다.  (시간 소요 있음.)

  ``` sh
  flutter doctor
  
  Running flutter doctor...
  Doctor summary (to see all details, run flutter doctor -v):
  [✓] Flutter (Channel stable, 3.0.4, on macOS 12.4 21F79 darwin-arm (Rosetta), locale ko-KR)
  [✓] Android toolchain - develop for Android devices (Android SDK version 30.0.3)
  [!] Xcode - develop for iOS and macOS (Xcode 13.4.1)
      ! CocoaPods 1.10.1 out of date (1.11.0 is recommended).
          CocoaPods is used to retrieve the iOS and macOS platform side's plugin code that responds to your plugin usage on the Dart side.
          Without CocoaPods, plugins will not work on iOS or macOS.
          For more info, see https://flutter.dev/platform-plugins
        To upgrade see https://guides.cocoapods.org/using/getting-started.html#installation for instructions.
  [✓] Chrome - develop for the web
  [✓] Android Studio (version 2021.1)
  [✓] IntelliJ IDEA Community Edition (version 2020.3.1)
  [✓] VS Code (version 1.68.0)
  [✓] Connected device (2 available)
  [✓] HTTP Host Availability
  
  ! Doctor found issues in 1 category.
  ```

- 처리를 위한 커맨드 또는 참고사항이 나오므로 이를 참조하여 각 해당사항을 처리 하도록 한다.

#### Xcode 설치

- 앱스토어에서 xcode를 선택하여 설치한다.
- Xcode는 추후 배포시에 사용된다. 개발 업무 자체는 Android 스튜디오에서 진행하도록 한다.
- IOS 버전 호환성은 10으로 설정한다. (flutter 코드에서 설정.)

#### Android 스튜디오 설치

- 최신 버전의 안드로이드 스튜디오를 다운로드 받는다.
- 설치 파일을 이용하여 설치를 수행한다.
- 안드로이드 sdk는 버전 별로 다운로드 할수 있으며, 프로젝트 생성시 지정도 가능하다.
- 윈도우의 경우 Standard 설치를 진행한다.
  - sdk 및 jre등이 모두 일반적인 설정으로 설치가 진행된다.
  - 설치후 해당 내용들의 수정이 가능함.
- sdk 등이 다운로드 되어 설치되므로, 인터넷 연결이 필수이여야 한다.
- 라이선스에 동의 한다.
- 설치도중 "Intel® HAXM installation failed." 메시지가 나올수 있으나. 해당 메시지는 안드로이드 스튜디오에서 사용하는 에뮬레이터의 가속을 위한 것으로 필수는 아님.
- 안드로이드 스튜디오 설치후 flutter와 연동.
  - 안드로이드 스튜디오에서 플러그인 검색을 통하여 flutter 플러그인을 설치한다. 필요한 dart 플러그인등을 같이 설치하게 된다.
  - 플러그인을 설치한 후 안드로이드 스튜디오를 재시작한다.
  - 시작창에 "New Flutter Project" 항목이 생성된다.
  - 설치 테스트 및 에뮬레이터 설정을 위하여 새로운 플러터 프로젝트를 생성한다.
  - 생성시 flutter sdk 항목에서 플러터 설치위치를 지정한다.
  - 프로젝트가 생성되면, 가상(에뮬레이터) 기기를 추가한다.
    - Tools 메뉴에서 Device Manager를 선택한다.
    - 가상 기기 생성을 선택한다.
    - 알맞은 사양의 기기를 선택하고, 가상기기에서 사용할 api 버전을 선택하면, 해당 이미지와 sdk 등이 다운로드 된다.
  - 가상기기가 추가되면, ide 상단 기기 선택창에 생성한 기기명이 나타난다. 
  - 빌드 및 실행 버튼을 눌러 연동상황을 테스트한다.

### 주요기능별 설정 및 구현

#### 써드파티 웹 인증 기능

- flutter web auth 라이브러리를 프로젝트에 추가 한다. pubspec.yaml 파일에 추가. (코딩시 부가적으로 필요한 uuid 생성 라이브러리 포함.)

  ``` yaml
  uuid: ^3.0.6
  flutter_web_auth: ^0.4.1
  ```

- Url scheme을 사용하기 위한 안드로이드 설정. (프로젝트위치/android/main/AndroidManifest.xml)

  ``` xml
  <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.flutter_oauth_test">
     <application
          android:label="flutter_oauth_test"
          android:name="${applicationName}"
          android:icon="@mipmap/ic_launcher">
          <activity
              android:name=".MainActivity"
              ......
          </activity>
          <activity android:name="com.linusu.flutter_web_auth.CallbackActivity" >
             <intent-filter android:label="flutter_web_auth">
                 <action android:name="android.intent.action.VIEW" />
                 <category android:name="android.intent.category.DEFAULT" />
                 <category android:name="android.intent.category.BROWSABLE" />
                 <data android:scheme="gongsacoknaverlogin" />
             </intent-filter>
          </activity>
          <!-- Don't delete the meta-data below.
               This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
          <meta-data
              android:name="flutterEmbedding"
              android:value="2" />
      </application>
  </manifest>
  ```

- 어플리케이션 내부에 activity 태그릉 이용하여 scheme 이름을 설정.

- 테스트를 위하여. Main.dart 파일에 버튼을 하나 생성하고, 해당 함수를 아래와 같이 구성한다.

  ``` dart
  clkTestButton() async {
      String BaseURL = "";
      // 에뮬레이터와 개발장비(localhost)의 통신을 위하여 각 os 별로 host ip를 설정한다. 서비스에서는 백엔드 서버의 주소를 사용하다록 한다.
      if(Platform.isAndroid) {
          BaseURL = "http://10.0.2.2:8080";
      }
      if(Platform.isIOS) {
          BaseURL = "http://127.0.0.1:8080";
      }
  
      final clientState = Uuid().v4();
    
      // 앱에서 새롭게 생성할 uri의 정보(이경우 네이버 로그인 창을 띄울 정보)를 설정한다.
      final authUri = Uri.https('nid.naver.com', '/oauth2.0/authorize', {
          'response_type': 'code',
          'client_id': 'CgwrY2ZJKgurXGVWpiTk',
          'response_mode': 'form_post',
          'redirect_uri': '${BaseURL}/pub/naverauth',
          'state': clientState,
      });
      // 위에서 생성한 정보를 기반으로 창을 새롭게 생성한다. 해당 콜백을 통해서 웹의 처리가 끝난 이후 다시 앱을 복귀한다.
      final authResponse = await FlutterWebAuth.authenticate(
          url: authUri.toString(),
          callbackUrlScheme: "gongsacoknaverlogin"
      );
  
      // 콜백을 통한 응답을 출력한다.
      print("tokenUri : "+authResponse);
  
      return;
  }
  ```

- 로그인 정상 수행시 콜백 응답의 예시는 아래와 같다.

  ``` sh
  I/flutter ( 7218): tokenUri : gongsacoknaverlogin://success?uid=4&userid=Naver:dRpPO1VTYNPN4jSPUt0pkwhkTrbNQq4AhAV1gMpPsHk&jtoken=eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJOYXZlcjpkUnBQTzFWVFlOUE40alNQVXQwcGt3aGtUcmJOUXE0QWhBVjFnTXBQc0hrIiwicm9sZXMiOiJST0xFX1VTRVIiLCJpYXQiOjE2NTcwODQyMzUsImV4cCI6MTY1NzE3MDYzNX0.GEA4K0HgD3reJd-vjwMIpM8LYUhwOXXEzgSLqgcmnFQ&userrole=ROLE_USER
  ```

### 배포

- 배포시 서비스 배포(앱 스토어, 플레이 스토어)와 테스트 배포(개발자 또는 테스터가 사용하는 배포본)으로 구분 할 수 있다.
- 또한 안드로이드와 iOS의 배포 방식 및 관리 방식(마켓)이 다름에 주의 하여야 한다.
- 테스트 배포
  - 안드로이드
  - iOS
- 서비스 실배포
  - 안드로이드
  - iOS

### Trouble shooting

- flutter doctor 실행시 xcode의 cocoapods 부재로 인한 오류보고가 있을수 있음.

  - cocoapods는 개발환경과 다른 플러그인 형태로 관리되므로 최신 버전으로 업그래이드를 위하여 터미널에서 설치를 진행한다.

    ``` sh
    sudo gem install cocoapods
    ```
  
- 실행이 안되고 계속 빌드가 진행중인 경우.

  - 터미널을 이용하여 프로젝트 디렉토리로 이동 하여 flutter 상세보기 모드로 실행.

    ``` sh
    flutter run -v
    ```
  
  - 출력을 참조하여 디버깅할 수 있다.
  
  - 특히 gradle 관련 출력후 오랜시간이 걸리는 경우. (전체 컴파일 또는 환경 변화시 자주 발생) 최대 20분까지 소요되는 경우가 있으므로, 충분히 대기 해본다.
  

## 웹 프론트엔드 (React)

### 프레임워크 특징

- 자바 스크립트 기반 웹앱 구현을 위한 페이스북에서 제안되고 관리되는 프레임워크.
- 웹 사이트의 html을 동적으로 생성하는 자바스크립트 형태로 설계된 프레임워크임.
- 다양한 모듈(라이브러리)를 손쉽게 관리할 수 있는 npm, yarn등의 환경과 결합하여, 손쉽게 동적인 기능을 구현할 수 있음.
- html 과는 다르게 서버에 배포되는 js를 생성해 주어야 하므로, 개발->컴파일->배포의 업무 형태를 준수하게 됨.
- 정적인 파일 수정을 위해서 소스코드의 수정이 필요한 경우가 발생 할 수있음.

## Database

### RDBMS 특징

- MySQL8 은 중소 규모의 서비스를 위한 오픈 소스 기반 관계형 데이터베이스 관리 시스템임.
- 성능에 비하여 오픈소스인 점으로 라이선스 비용등이 존재 하지 않아 초기 비용이 저렴함.
- 확장성이 넓어 많은 비즈니스 모델에서 적용되고 있음
  - 다양한 사용 방식에 대한 관련 레퍼런스가 많음.
  - 개발 환경에 따른 다양한 라이브러리 지원 및 관련 Best Practice를 쉽게 적용할 수 있음.

### ubuntu 서버에 mysql-8 설치

- https://hyunmin1906.tistory.com/265 정보 참고로 데이터 베이스 설치.

  - mysqld.conf 를 편집하여, 외부 접속 및 한글처리에 관련한 설정을 하도록 한다.

    ``` sh
    bind-address=0.0.0.0
    character-set-server=utf8 
    collation-server=utf8_general_ci 
    init_connect=SET collation_connection = utf8_general_ci 
    init_connect=SET NAMES utf8
    ```

  - 향후 AWS의 RDS 서비스를 활용하는 경우, 설치 방법이 필요하지 않으므로, 개발자 자체의 개발 환경을 위한 데이터베이스 설치는 개발자 개인의 취향에 따라서 설치하도록 한다.
  
  - 추천방안 : Docker Container를 활용한 mysql 8 설치 및 활용.

### Database and user creation

- 데이터베이스 생성

  ``` sql
  create database cokdev
  ```

- 사용자 생성

  ``` sql
  create user 'cokdev'@'%' identified by 'cokroqkf'
  flush privileges
  ```

- 권한 부여

  - 일반적으로 db의 설정은 전체 open으로 하고, 전단 os 레벨, 또는 aws 방화벽 규칙을 통하여 접속 ip를 통제한다.

  - 보안 관련 인적 실수를 줄이기 위하여 db의 보안 설정도 각각 ip 별로 부여하는 것을 추천한다.

    ``` sql
    grant all privileges on cokdev.* to 'cokdev'@'%'
    flush privileges
    ```

- 외부 접속 테스트

  - dbeaver등의 데이터 베이스 접속 툴을 이용하여 외부 접속을 확인한다.

### Table 구성

- user_info : 로그인 관련 사용자 정보 테이블
- user_detail_info : 사용자의 상세 정보 테이블
  - ruid 필드를 통하여 user_info 테이블과 연관된다.
- Image_info : 업로드 이미지 정보 테이블
- use_log : 데이터 베이스 기록용 로그 테이블

### Trouble Shooting

- dbeaver를 통해 외부접속 시 "AllowPublicKeyRetrival = True" 로 드라이버를 설정한다. 
